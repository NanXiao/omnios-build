Fixes CVE-2021-3177.
Desc:
  Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in
  _ctypes/callproc.c, which may lead to remote code execution in certain
  Python applications that accept floating-point numbers as untrusted input,
  as demonstrated by a 1e300 argument to c_double.from_param. This occurs
  because sprintf is used unsafely.

Upstream bug: https://bugs.python.org/issue42938

Backported from upstream:
https://github.com/python/cpython/pull/24239

--- src~/Modules/_ctypes/callproc.c	2020-09-05 07:22:07.000000000 +0000
+++ src/Modules/_ctypes/callproc.c	2021-02-24 23:48:40.002170967 +0000
@@ -448,57 +448,60 @@
     PyObject_Del(self);
 }
 
+/* maximum number of characters required for output of %lld or %p.
+   We need at most ceil(log10(256)*SIZEOF_LONG_LONG) digits,
+   plus 1 for the sign.  53/22 is an upper bound for log10(256). */
+#define MAX_LONG_LONG_CHARS (2 + (SIZEOF_LONG_LONG*53-1) / 22)
+
 static PyObject *
 PyCArg_repr(PyCArgObject *self)
 {
-    char buffer[256];
     switch(self->tag) {
     case 'b':
     case 'B':
-        sprintf(buffer, "<cparam '%c' (%d)>",
+        return PyUnicode_FromFormat("<cparam '%c' (%d)>",
             self->tag, self->value.b);
-        break;
     case 'h':
     case 'H':
-        sprintf(buffer, "<cparam '%c' (%d)>",
+        return PyUnicode_FromFormat("<cparam '%c' (%d)>",
             self->tag, self->value.h);
-        break;
     case 'i':
     case 'I':
-        sprintf(buffer, "<cparam '%c' (%d)>",
+        return PyUnicode_FromFormat("<cparam '%c' (%d)>",
             self->tag, self->value.i);
-        break;
     case 'l':
     case 'L':
-        sprintf(buffer, "<cparam '%c' (%ld)>",
+        return PyUnicode_FromFormat("<cparam '%c' (%ld)>",
             self->tag, self->value.l);
-        break;
 
 #ifdef HAVE_LONG_LONG
     case 'q':
-    case 'Q':
-        sprintf(buffer,
+    case 'Q': {
+        char buffer[MAX_LONG_LONG_CHARS + 15];
+        snprintf(buffer, MAX_LONG_LONG_CHARS + 15,
 #ifdef MS_WIN32
             "<cparam '%c' (%I64d)>",
 #else
             "<cparam '%c' (%qd)>",
 #endif
             self->tag, self->value.q);
-        break;
+        return PyUnicode_FromString(buffer);
+    }
 #endif
     case 'd':
-        sprintf(buffer, "<cparam '%c' (%f)>",
-            self->tag, self->value.d);
-        break;
-    case 'f':
-        sprintf(buffer, "<cparam '%c' (%f)>",
-            self->tag, self->value.f);
-        break;
+    case 'f': {
+        PyObject *f = PyFloat_FromDouble((self->tag == 'f') ? self->value.f : self->value.d);
+        if (f == NULL) {
+            return NULL;
+        }
+        PyObject *result = PyUnicode_FromFormat("<cparam '%c' (%R)>", self->tag, f);
+        Py_DECREF(f);
+        return result;
+    }
 
     case 'c':
-        sprintf(buffer, "<cparam '%c' (%c)>",
+        return PyUnicode_FromFormat("<cparam '%c' ('%c')>",
             self->tag, self->value.c);
-        break;
 
 /* Hm, are these 'z' and 'Z' codes useful at all?
    Shouldn't they be replaced by the functionality of c_string
@@ -507,16 +509,13 @@
     case 'z':
     case 'Z':
     case 'P':
-        sprintf(buffer, "<cparam '%c' (%p)>",
+        return PyUnicode_FromFormat("<cparam '%c' (%p)>",
             self->tag, self->value.p);
-        break;
 
     default:
-        sprintf(buffer, "<cparam '%c' at %p>",
+        return PyUnicode_FromFormat("<cparam '%c' at %p>",
             self->tag, self);
-        break;
     }
-    return PyUnicode_FromString(buffer);
 }
 
 static PyMemberDef PyCArgType_members[] = {
